package leetcode.misc;

import java.util.Arrays;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.Map;
import java.util.Queue;
import java.util.Set;


/*
Runtime: 121 ms, faster than 23.35% of Java online submissions for Minimize Malware Spread II.
 */
public class MinimizeMalwareSpreadII {

    Map<Integer, Set<Integer>> map = new LinkedHashMap();
    int[] init;
    int[][] g;
    Set<Integer> initSet = new HashSet<>();

    public int minMalwareSpread(int[][] graph, int[] initial) {
        init = initial;
        Arrays.sort(init);
        g = graph;
        Set<Integer> infected = new HashSet<Integer>();

        for (int i = 0; i < init.length; i++)
            initSet.add(init[i]);

        for (int i = 0; i < init.length; i++) {
            Set s = reachableFrom(init[i]);
            map.put(init[i], s);
        }

        int[] score = new int[init.length];
        System.out.println("match " + map);
        for (int i = 0; i < g.length; i++) {

            if (!initSet.contains(i)) {

                int matches = 0;
                int match = -1;
                for (Map.Entry<Integer, Set<Integer>> entry : map.entrySet()) {

                    if (entry.getValue().contains(i)) {
                        matches++;
                        match = entry.getKey();
                    }
                }

                if (matches == 1) {
                    for (int p = 0; p < init.length; p++) {
                        if (init[p] == match) {
                            score[p]++;
                            break;
                        }
                    }
                }
            }
        }

        int ind = 0;
        int max = score[0];

        for (int i = 1; i < score.length; i++) {
            if (max < score[i]) {
                max = score[i];
                ind = i;
            }
        }

        return init[ind];
    }

    Set<Integer> reachableFrom(int i) {

        Queue<Integer> q = new LinkedList<Integer>();
        q.add(i);
        Set<Integer> result = new HashSet();

        while (!q.isEmpty()) {

            int k = q.poll();

            for (int j = 0; j < g.length; j++) {

                if (j != i && g[k][j] == 1 && !result.contains(j) && !initSet.contains(j)) {
                    result.add(j);
                    q.add(j);
                }
            }
        }

        return result;
    }

}
